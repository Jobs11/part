<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.part.mapper.PartIncomingMapper">

    <!-- ResultMap -->
    <resultMap id="incomingResultMap" type="com.example.part.dto.PartIncomingDTO">
        <id property="incomingId" column="incoming_id"/>
        <result property="partNumber" column="part_number"/>
        <result property="categoryId" column="category_id"/>
        <result property="categoryName" column="category_name"/>
        <result property="partName" column="part_name"/>
        <result property="description" column="description"/>
        <result property="projectName" column="project_name"/>
        <result property="unit" column="unit"/>
        <result property="paymentMethodId" column="payment_method_id"/>
        <result property="paymentMethodName" column="payment_method_name"/>
        <result property="incomingQuantity" column="incoming_quantity"/>
        <result property="purchasePrice" column="purchase_price"/>
        <result property="currency" column="currency"/>
        <result property="exchangeRate" column="exchange_rate"/>
        <result property="originalPrice" column="original_price"/>
        <result property="purchaseDatetime" column="purchase_datetime"/>
        <result property="supplier" column="supplier"/>
        <result property="purchaser" column="purchaser"/>
        <result property="invoiceNumber" column="invoice_number"/>
        <result property="note" column="note"/>
        <result property="createdBy" column="created_by"/>
        <result property="createdAt" column="created_at"/>
    </resultMap>

    <!-- âœ… ìž…ê³  ë“±ë¡ -->
    <insert id="insertIncoming" parameterType="com.example.part.dto.PartIncomingDTO" useGeneratedKeys="true" keyProperty="incomingId">
        INSERT INTO part_incoming (
            part_number,
            category_id,
            part_name,
            description,
            project_name,
            unit,
            payment_method_id,
            incoming_quantity,
            purchase_price,
            currency,
            exchange_rate,
            original_price,
            purchase_datetime,
            supplier,
            purchaser,
            invoice_number,
            note,
            created_by
        ) VALUES (
            #{partNumber},
            #{categoryId},
            #{partName},
            #{description},
            #{projectName},
            #{unit},
            #{paymentMethodId},
            #{incomingQuantity},
            #{purchasePrice},
            #{currency},
            #{exchangeRate},
            #{originalPrice},
            #{purchaseDatetime},
            #{supplier},
            #{purchaser},
            #{invoiceNumber},
            #{note},
            #{createdBy}
        )
    </insert>

    <!-- âœ… ì „ì²´ ìž…ê³  ë‚´ì—­ ì¡°íšŒ -->
    <select id="selectAllIncoming" resultMap="incomingResultMap">
        SELECT
            pi.*,
            c.category_name AS category_name,
            pm.category_name AS payment_method_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN category pm ON pi.payment_method_id = pm.category_id
        ORDER BY pi.created_at DESC
    </select>

    <!-- âœ… incoming_idë¡œ ë‹¨ê±´ ì¡°íšŒ -->
    <select id="findById" resultMap="incomingResultMap" parameterType="int">
        SELECT
            pi.*,
            c.category_name AS category_name,
            pm.category_name AS payment_method_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN category pm ON pi.payment_method_id = pm.category_id
        WHERE pi.incoming_id = #{incomingId}
    </select>

    <!-- âœ… íŠ¹ì • ë¶€í’ˆë²ˆí˜¸ë¡œ ì¡°íšŒ -->
    <select id="findByPartNumber" resultMap="incomingResultMap" parameterType="string">
        SELECT
            pi.*,
            c.category_name AS category_name,
            pm.category_name AS payment_method_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN category pm ON pi.payment_method_id = pm.category_id
        WHERE pi.part_number = #{partNumber}
        ORDER BY pi.created_at DESC
    </select>

    <!-- âœ… ë¶€í’ˆëª…ìœ¼ë¡œ ê²€ìƒ‰ -->
    <select id="searchByPartName" resultMap="incomingResultMap" parameterType="string">
        SELECT
            pi.*,
            c.category_name AS category_name,
            pm.category_name AS payment_method_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN category pm ON pi.payment_method_id = pm.category_id
        WHERE pi.part_name LIKE CONCAT('%', #{partName}, '%')
        OR pi.part_number LIKE CONCAT('%', #{partName}, '%')
        ORDER BY pi.created_at DESC
    </select>

    <!-- âœ… ì¹´í…Œê³ ë¦¬ë³„ ìž…ê³  ë‚´ì—­ -->
    <select id="selectIncomingByCategory" resultMap="incomingResultMap" parameterType="int">
        SELECT
            pi.*,
            c.category_name AS category_name,
            pm.category_name AS payment_method_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN category pm ON pi.payment_method_id = pm.category_id
        WHERE pi.category_id = #{categoryId}
        ORDER BY pi.created_at DESC
    </select>

    <!-- âœ… ë¶€í’ˆë³„ í˜„ìž¬ ìž¬ê³  ì§‘ê³„ -->
    <select id="getCurrentInventory" resultType="map">
        SELECT
            pi.part_number,
            (SELECT pi2.part_name
             FROM part_incoming pi2
             WHERE pi2.part_number = pi.part_number
             ORDER BY pi2.incoming_id ASC
             LIMIT 1) AS part_name,
            (SELECT c2.category_name
             FROM part_incoming pi3
             LEFT JOIN category c2 ON pi3.category_id = c2.category_id
             WHERE pi3.part_number = pi.part_number
             ORDER BY pi3.incoming_id ASC
             LIMIT 1) AS category_name,
            (SELECT pi4.unit
             FROM part_incoming pi4
             WHERE pi4.part_number = pi.part_number
             ORDER BY pi4.incoming_id ASC
             LIMIT 1) AS unit,
            SUM(pi.incoming_quantity) AS total_incoming,
            COALESCE(SUM(pu.quantity_used), 0) AS total_used,
            (SUM(pi.incoming_quantity) - COALESCE(SUM(pu.quantity_used), 0)) AS current_stock,
            COUNT(DISTINCT pi.incoming_id) AS incoming_count
        FROM part_incoming pi
        LEFT JOIN part_usage pu ON pi.incoming_id = pu.incoming_id
        GROUP BY pi.part_number
        ORDER BY pi.part_number
    </select>

    <!-- í˜„ìž¬ ìž¬ê³  ê³ ê¸‰ ê²€ìƒ‰ -->
    <select id="searchInventoryAdvanced" resultType="map" parameterType="map">
        SELECT
            pi.part_number,
            (SELECT pi2.part_name
             FROM part_incoming pi2
             WHERE pi2.part_number = pi.part_number
             ORDER BY pi2.incoming_id ASC
             LIMIT 1) AS part_name,
            (SELECT c2.category_name
             FROM part_incoming pi3
             LEFT JOIN category c2 ON pi3.category_id = c2.category_id
             WHERE pi3.part_number = pi.part_number
             ORDER BY pi3.incoming_id ASC
             LIMIT 1) AS category_name,
            (SELECT pi4.unit
             FROM part_incoming pi4
             WHERE pi4.part_number = pi.part_number
             ORDER BY pi4.incoming_id ASC
             LIMIT 1) AS unit,
            SUM(pi.incoming_quantity) AS total_incoming,
            COALESCE(SUM(pu.quantity_used), 0) AS total_used,
            (SUM(pi.incoming_quantity) - COALESCE(SUM(pu.quantity_used), 0)) AS current_stock,
            COUNT(DISTINCT pi.incoming_id) AS incoming_count
        FROM part_incoming pi
        LEFT JOIN part_usage pu ON pi.incoming_id = pu.incoming_id
        WHERE 1 = 1

        <if test="columnKey != null and columnKey != '' and keyword != null and keyword != '' and columnKey == 'part_number'">
            AND pi.part_number LIKE CONCAT('%', #{keyword}, '%')
        </if>

        <if test="(columnKey == null or columnKey == '') and keyword != null and keyword != ''">
            AND pi.part_number LIKE CONCAT('%', #{keyword}, '%')
        </if>

        <foreach collection="includeList" item="kw">
            AND pi.part_number LIKE CONCAT('%', #{kw}, '%')
        </foreach>

        <foreach collection="excludeList" item="kw">
            AND NOT (pi.part_number LIKE CONCAT('%', #{kw}, '%'))
        </foreach>

        GROUP BY pi.part_number

        HAVING 1 = 1

        <if test="columnKey != null and columnKey != '' and keyword != null and keyword != '' and columnKey == 'part_name'">
            AND part_name LIKE CONCAT('%', #{keyword}, '%')
        </if>

        <if test="columnKey != null and columnKey != '' and keyword != null and keyword != '' and columnKey == 'category_name'">
            AND category_name LIKE CONCAT('%', #{keyword}, '%')
        </if>

        <if test="columnKey != null and columnKey != '' and keyword != null and keyword != '' and columnKey == 'current_stock'">
            AND CAST(current_stock AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
        </if>

        <if test="columnKey != null and columnKey != '' and keyword != null and keyword != '' and columnKey == 'total_incoming'">
            AND CAST(total_incoming AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
        </if>

        <if test="columnKey != null and columnKey != '' and keyword != null and keyword != '' and columnKey == 'total_used'">
            AND CAST(total_used AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
        </if>

        <if test="columnKey != null and columnKey != '' and keyword != null and keyword != '' and columnKey == 'incoming_count'">
            AND CAST(incoming_count AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
        </if>

        <!-- + í¬í•¨ ê²€ìƒ‰ (part_name) -->
        <foreach collection="includeList" item="kw">
            AND part_name LIKE CONCAT('%', #{kw}, '%')
        </foreach>

        <!-- - ë¯¸í¬í•¨ ê²€ìƒ‰ (part_name) -->
        <foreach collection="excludeList" item="kw">
            AND NOT (part_name LIKE CONCAT('%', #{kw}, '%'))
        </foreach>

        ORDER BY
        <choose>
            <when test="orderColumn != null and orderColumn != ''">
                ${orderColumn} ${order}
            </when>
            <otherwise>
                pi.part_number ASC
            </otherwise>
        </choose>
    </select>
    <!-- âœ… ìž¬ê³  ë¶€ì¡± ì¡°íšŒ (í˜„ìž¬ ìž¬ê³  ê¸°ì¤€) -->
    <select id="selectLowStock" resultType="map" parameterType="int">
        SELECT
            pi.part_number,
            (SELECT pi2.part_name
             FROM part_incoming pi2
             WHERE pi2.part_number = pi.part_number
             ORDER BY pi2.incoming_id ASC
             LIMIT 1) AS part_name,
            (SELECT c2.category_name
             FROM part_incoming pi3
             LEFT JOIN category c2 ON pi3.category_id = c2.category_id
             WHERE pi3.part_number = pi.part_number
             ORDER BY pi3.incoming_id ASC
             LIMIT 1) AS category_name,
            (SELECT pi4.unit
             FROM part_incoming pi4
             WHERE pi4.part_number = pi.part_number
             ORDER BY pi4.incoming_id ASC
             LIMIT 1) AS unit,
            (SUM(pi.incoming_quantity) - COALESCE(SUM(pu.quantity_used), 0)) AS current_stock
        FROM part_incoming pi
        LEFT JOIN part_usage pu ON pi.incoming_id = pu.incoming_id
        GROUP BY pi.part_number
        HAVING current_stock &lt;= #{threshold}
        ORDER BY current_stock ASC
    </select>

    <!-- âœ… ìž…ê³  ì •ë³´ ìˆ˜ì • -->
    <update id="updateIncoming" parameterType="com.example.part.dto.PartIncomingDTO">
        UPDATE part_incoming
        SET
            part_number = #{partNumber},
            category_id = #{categoryId},
            part_name = #{partName},
            description = #{description},
            project_name = #{projectName},
            unit = #{unit},
            payment_method_id = #{paymentMethodId},
            incoming_quantity = #{incomingQuantity},
            purchase_price = #{purchasePrice},
            currency = #{currency},
            exchange_rate = #{exchangeRate},
            original_price = #{originalPrice},
            purchase_datetime = #{purchaseDatetime},
            supplier = #{supplier},
            purchaser = #{purchaser},
            invoice_number = #{invoiceNumber},
            note = #{note}
        WHERE incoming_id = #{incomingId}
    </update>

    <!-- âœ… ì •ë ¬ (ë™ì ) -->
    <select id="getIncomingOrderBy" resultMap="incomingResultMap">
        SELECT
            pi.*,
            c.category_name AS category_name,
            pm.category_name AS payment_method_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN category pm ON pi.payment_method_id = pm.category_id
        ORDER BY ${column} ${order}
    </select>

    <!-- ì¹´í…Œê³ ë¦¬ + ë¶€í’ˆëª…ìœ¼ë¡œ ê¸°ì¡´ ë¶€í’ˆ ì°¾ê¸° -->
    <select id="findByPartNameAndCategory" resultMap="incomingResultMap">
        SELECT
            pi.*,
            c.category_name AS category_name,
            pm.category_name AS payment_method_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN category pm ON pi.payment_method_id = pm.category_id
        WHERE pi.category_id = #{categoryId}
        AND pi.part_name = #{partName}
        ORDER BY pi.created_at DESC
        LIMIT 1
    </select>

    <!-- ê²€ìƒ‰ + ì •ë ¬ í†µí•© -->
    <select id="searchWithSort" resultMap="incomingResultMap">
        SELECT
            pi.*,
            c.category_name AS category_name,
            pm.category_name AS payment_method_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN category pm ON pi.payment_method_id = pm.category_id
        WHERE pi.part_name LIKE CONCAT('%', #{keyword}, '%')
        OR pi.part_number LIKE CONCAT('%', #{keyword}, '%')
        OR pm.category_name LIKE CONCAT('%', #{keyword}, '%')
        ORDER BY ${column} ${order}
    </select>

    <!-- ðŸ” ê³ ê¸‰ ê²€ìƒ‰ (ì»¬ëŸ¼ ê²€ìƒ‰ + +í¬í•¨ + -ì œì™¸ + ì „ì²´ê²€ìƒ‰) -->
    <select id="searchAdvanced" resultMap="incomingResultMap" parameterType="map">
        SELECT
            pi.*,
            c.category_name AS category_name,
            pm.category_name AS payment_method_name,
            pl.pos_x,
            pl.pos_y,
            pl.location_code
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN category pm ON pi.payment_method_id = pm.category_id
        LEFT JOIN part_location pl ON pi.incoming_id = pl.incoming_id
        WHERE 1 = 1

        <!-- ================================
            1) ì»¬ëŸ¼ ê²€ìƒ‰ (column ì§€ì •ëœ ê²½ìš°)
            ================================ -->
        <if test="column != null and column != '' and keyword != null and keyword != ''">
            <choose>
                <!-- ìˆ«ìž ì»¬ëŸ¼ë„ LIKEë¡œ í¬í•¨ ê²€ìƒ‰ -->
                <when test="column == 'incoming_quantity'
                        or column == 'purchase_price'
                        or column == 'pi.incoming_quantity'
                        or column == 'pi.purchase_price'">
                    AND CAST(${column} AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
                </when>
                <!-- í…ìŠ¤íŠ¸ ì»¬ëŸ¼ì€ LIKE ê²€ìƒ‰ -->
                <otherwise>
                    AND ${column} LIKE CONCAT('%', #{keyword}, '%')
                </otherwise>
            </choose>
        </if>

        <!-- ===================================
            2) ì „ì²´ ê²€ìƒ‰ (columnì´ ì—†ì„ ë•Œë§Œ ì‹¤í–‰)
            =================================== -->
        <if test="(column == null or column == '')
                and keyword != null and keyword != ''">
            AND (
                pi.part_number LIKE CONCAT('%', #{keyword}, '%')
                OR pi.part_name LIKE CONCAT('%', #{keyword}, '%')
                OR pi.description LIKE CONCAT('%', #{keyword}, '%')
                OR pi.project_name LIKE CONCAT('%', #{keyword}, '%')
                OR c.category_name LIKE CONCAT('%', #{keyword}, '%')
                OR pm.category_name LIKE CONCAT('%', #{keyword}, '%')
                OR COALESCE(pl.location_code, CONCAT(pl.pos_x, '-', pl.pos_y)) LIKE CONCAT('%', #{keyword}, '%')
            )
        </if>

        <!-- ================================
            3) + í¬í•¨ ê²€ìƒ‰
            ================================ -->
        <foreach collection="includeList" item="kw">
            <choose>
                <!-- ì»¬ëŸ¼ì´ ì§€ì •ëœ ê²½ìš° í•´ë‹¹ ì»¬ëŸ¼ë§Œ ê²€ìƒ‰ -->
                <when test="column != null and column != ''">
                    <choose>
                        <!-- ìˆ«ìž/ë‚ ì§œ ì»¬ëŸ¼ì€ CAST ì²˜ë¦¬ -->
                        <when test="column == 'incoming_quantity'
                                or column == 'purchase_price'
                                or column == 'pi.incoming_quantity'
                                or column == 'pi.purchase_price'
                                or column == 'purchase_datetime'
                                or column == 'pi.purchase_datetime'">
                            AND CAST(${column} AS CHAR) LIKE CONCAT('%', #{kw}, '%')
                        </when>
                        <!-- í…ìŠ¤íŠ¸ ì»¬ëŸ¼ -->
                        <otherwise>
                            AND ${column} LIKE CONCAT('%', #{kw}, '%')
                        </otherwise>
                    </choose>
                </when>
                <!-- ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ì „ì²´ ê²€ìƒ‰ -->
                <otherwise>
                    AND (
                        pi.part_number LIKE CONCAT('%', #{kw}, '%')
                        OR pi.part_name LIKE CONCAT('%', #{kw}, '%')
                        OR pi.description LIKE CONCAT('%', #{kw}, '%')
                        OR pi.project_name LIKE CONCAT('%', #{kw}, '%')
                        OR c.category_name LIKE CONCAT('%', #{kw}, '%')
                        OR pm.category_name LIKE CONCAT('%', #{kw}, '%')
                        OR CAST(pi.incoming_quantity AS CHAR) LIKE CONCAT('%', #{kw}, '%')
                        OR CAST(pi.purchase_price AS CHAR) LIKE CONCAT('%', #{kw}, '%')
                        OR CAST(pi.purchase_datetime AS CHAR) LIKE CONCAT('%', #{kw}, '%')
                        OR COALESCE(pl.location_code, CONCAT(pl.pos_x, '-', pl.pos_y)) LIKE CONCAT('%', #{kw}, '%')
                    )
                </otherwise>
            </choose>
        </foreach>

        <!-- ================================
            4) - ì œì™¸ ê²€ìƒ‰
            ================================ -->
        <foreach collection="excludeList" item="kw">
            <choose>
                <!-- ì»¬ëŸ¼ì´ ì§€ì •ëœ ê²½ìš° í•´ë‹¹ ì»¬ëŸ¼ë§Œ ì œì™¸ -->
                <when test="column != null and column != ''">
                    <choose>
                        <!-- ìˆ«ìž/ë‚ ì§œ ì»¬ëŸ¼ì€ CAST ì²˜ë¦¬ -->
                        <when test="column == 'incoming_quantity'
                                or column == 'purchase_price'
                                or column == 'pi.incoming_quantity'
                                or column == 'pi.purchase_price'
                                or column == 'purchase_datetime'
                                or column == 'pi.purchase_datetime'">
                            AND NOT (CAST(${column} AS CHAR) LIKE CONCAT('%', #{kw}, '%'))
                        </when>
                        <!-- í…ìŠ¤íŠ¸ ì»¬ëŸ¼ -->
                        <otherwise>
                            AND NOT (${column} LIKE CONCAT('%', #{kw}, '%'))
                        </otherwise>
                    </choose>
                </when>
                <!-- ì»¬ëŸ¼ì´ ì—†ìœ¼ë©´ ì „ì²´ì—ì„œ ì œì™¸ -->
                <otherwise>
                    AND NOT (
                        COALESCE(pi.part_number, '') LIKE CONCAT('%', #{kw}, '%')
                        OR COALESCE(pi.part_name, '') LIKE CONCAT('%', #{kw}, '%')
                        OR COALESCE(pi.description, '') LIKE CONCAT('%', #{kw}, '%')
                        OR COALESCE(pi.project_name, '') LIKE CONCAT('%', #{kw}, '%')
                        OR COALESCE(c.category_name, '') LIKE CONCAT('%', #{kw}, '%')
                        OR COALESCE(pm.category_name, '') LIKE CONCAT('%', #{kw}, '%')
                        OR CAST(pi.incoming_quantity AS CHAR) LIKE CONCAT('%', #{kw}, '%')
                        OR CAST(pi.purchase_price AS CHAR) LIKE CONCAT('%', #{kw}, '%')
                        OR CAST(pi.purchase_datetime AS CHAR) LIKE CONCAT('%', #{kw}, '%')
                        OR COALESCE(pl.location_code, CONCAT(pl.pos_x, '-', pl.pos_y)) LIKE CONCAT('%', #{kw}, '%')
                    )
                </otherwise>
            </choose>
        </foreach>

        <!-- ================================
            5) ì •ë ¬ (sortColumnì´ ìžˆìœ¼ë©´ ê·¸ ì»¬ëŸ¼ìœ¼ë¡œ, ì—†ìœ¼ë©´ column ì‚¬ìš©)
            ================================ -->
        ORDER BY
        <choose>
            <when test="sortColumn != null and sortColumn != ''">
                ${sortColumn} ${order}
            </when>
            <when test="column != null and column != ''">
                ${column} ${order}
            </when>
            <otherwise>
                pi.created_at DESC
            </otherwise>
        </choose>
    </select>


</mapper>
