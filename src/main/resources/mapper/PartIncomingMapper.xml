<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.part.mapper.PartIncomingMapper">

    <!-- ResultMap -->
    <resultMap id="incomingResultMap" type="com.example.part.dto.PartIncomingDTO">
        <id property="incomingId" column="incoming_id"/>
        <result property="partNumber" column="part_number"/>
        <result property="categoryId" column="category_id"/>
        <result property="categoryName" column="category_name"/>
        <result property="partName" column="part_name"/>
        <result property="description" column="description"/>
        <result property="unit" column="unit"/>
        <result property="incomingQuantity" column="incoming_quantity"/>
        <result property="purchasePrice" column="purchase_price"/>
        <result property="currency" column="currency"/>
        <result property="exchangeRate" column="exchange_rate"/>
        <result property="originalPrice" column="original_price"/>
        <result property="purchaseDate" column="purchase_date"/>
        <result property="supplier" column="supplier"/>
        <result property="invoiceNumber" column="invoice_number"/>
        <result property="note" column="note"/>
        <result property="createdBy" column="created_by"/>
        <result property="createdAt" column="created_at"/>
    </resultMap>

    <!-- âœ… ìž…ê³  ë“±ë¡ -->
    <insert id="insertIncoming" parameterType="com.example.part.dto.PartIncomingDTO" useGeneratedKeys="true" keyProperty="incomingId">
        INSERT INTO part_incoming (
            part_number,
            category_id,
            part_name,
            description,
            unit,
            incoming_quantity,
            purchase_price,
            currency,
            exchange_rate,
            original_price,
            purchase_date,
            supplier,
            invoice_number,
            note,
            created_by
        ) VALUES (
            #{partNumber},
            #{categoryId},
            #{partName},
            #{description},
            #{unit},
            #{incomingQuantity},
            #{purchasePrice},
            #{currency},
            #{exchangeRate},
            #{originalPrice},
            #{purchaseDate},
            #{supplier},
            #{invoiceNumber},
            #{note},
            #{createdBy}
        )
    </insert>

    <!-- âœ… ì „ì²´ ìž…ê³  ë‚´ì—­ ì¡°íšŒ -->
    <select id="selectAllIncoming" resultMap="incomingResultMap">
        SELECT
            pi.*,
            c.category_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        ORDER BY pi.created_at ASC
    </select>

    <!-- âœ… incoming_idë¡œ ë‹¨ê±´ ì¡°íšŒ -->
    <select id="findById" resultMap="incomingResultMap" parameterType="int">
        SELECT
            pi.*,
            c.category_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        WHERE pi.incoming_id = #{incomingId}
    </select>

    <!-- âœ… íŠ¹ì • ë¶€í’ˆë²ˆí˜¸ë¡œ ì¡°íšŒ -->
    <select id="findByPartNumber" resultMap="incomingResultMap" parameterType="string">
        SELECT
            pi.*,
            c.category_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        WHERE pi.part_number = #{partNumber}
        ORDER BY pi.created_at DESC
    </select>

    <!-- âœ… ë¶€í’ˆëª…ìœ¼ë¡œ ê²€ìƒ‰ -->
    <select id="searchByPartName" resultMap="incomingResultMap" parameterType="string">
        SELECT
            pi.*,
            c.category_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        WHERE pi.part_name LIKE CONCAT('%', #{partName}, '%')
        OR pi.part_number LIKE CONCAT('%', #{partName}, '%')
        ORDER BY pi.created_at DESC
    </select>

    <!-- âœ… ì¹´í…Œê³ ë¦¬ë³„ ìž…ê³  ë‚´ì—­ -->
    <select id="selectIncomingByCategory" resultMap="incomingResultMap" parameterType="int">
        SELECT
            pi.*,
            c.category_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        WHERE pi.category_id = #{categoryId}
        ORDER BY pi.created_at DESC
    </select>

    <!-- âœ… ë¶€í’ˆë³„ í˜„ìž¬ ìž¬ê³  ì§‘ê³„ -->
    <select id="getCurrentInventory" resultType="map">
        SELECT
            pi.part_number,
            pi.part_name,
            c.category_name,
            pi.unit,
            SUM(pi.incoming_quantity) AS total_incoming,
            COALESCE(SUM(pu.quantity_used), 0) AS total_used,
            (SUM(pi.incoming_quantity) - COALESCE(SUM(pu.quantity_used), 0)) AS current_stock,
            COUNT(DISTINCT pi.incoming_id) AS incoming_count
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN part_usage pu ON pi.incoming_id = pu.incoming_id
        GROUP BY pi.part_number, pi.part_name, c.category_name, pi.unit
        ORDER BY pi.part_number
    </select>

    <!-- í˜„ìž¬ ìž¬ê³  ê³ ê¸‰ ê²€ìƒ‰ -->
    <select id="searchInventoryAdvanced" resultType="map" parameterType="map">
        SELECT
            pi.part_number,
            pi.part_name,
            c.category_name,
            pi.unit,
            SUM(pi.incoming_quantity) AS total_incoming,
            COALESCE(SUM(pu.quantity_used), 0) AS total_used,
            (SUM(pi.incoming_quantity) - COALESCE(SUM(pu.quantity_used), 0)) AS current_stock,
            COUNT(DISTINCT pi.incoming_id) AS incoming_count
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN part_usage pu ON pi.incoming_id = pu.incoming_id
        WHERE 1 = 1

        <choose>
            <when test="columnKey != null and columnKey != '' and keyword != null and keyword != ''">
                <choose>
                    <when test="columnKey == 'part_number'">
                        AND pi.part_number LIKE CONCAT('%', #{keyword}, '%')
                    </when>
                    <when test="columnKey == 'part_name'">
                        AND pi.part_name LIKE CONCAT('%', #{keyword}, '%')
                    </when>
                    <when test="columnKey == 'category_name'">
                        AND c.category_name LIKE CONCAT('%', #{keyword}, '%')
                    </when>
                </choose>
            </when>
            <otherwise>
                <if test="keyword != null and keyword != ''">
                    AND (
                        pi.part_number LIKE CONCAT('%', #{keyword}, '%')
                        OR pi.part_name LIKE CONCAT('%', #{keyword}, '%')
                        OR c.category_name LIKE CONCAT('%', #{keyword}, '%')
                    )
                </if>
            </otherwise>
        </choose>

        <foreach collection="includeList" item="kw">
            AND (
                pi.part_number LIKE CONCAT('%', #{kw}, '%')
                OR pi.part_name LIKE CONCAT('%', #{kw}, '%')
                OR c.category_name LIKE CONCAT('%', #{kw}, '%')
            )
        </foreach>

        <foreach collection="excludeList" item="kw">
            AND (
                pi.part_number NOT LIKE CONCAT('%', #{kw}, '%')
                AND pi.part_name NOT LIKE CONCAT('%', #{kw}, '%')
                AND c.category_name NOT LIKE CONCAT('%', #{kw}, '%')
            )
        </foreach>

        GROUP BY pi.part_number, pi.part_name, c.category_name, pi.unit

        <!-- ìˆ«ìž ì»¬ëŸ¼ ê²€ìƒ‰ (HAVING ì ˆ ì‚¬ìš©, LIKEë¡œ í¬í•¨ ê²€ìƒ‰) -->
        <if test="columnKey != null and columnKey != '' and keyword != null and keyword != ''">
            <choose>
                <when test="columnKey == 'current_stock'">
                    HAVING CAST(current_stock AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
                </when>
                <when test="columnKey == 'total_incoming'">
                    HAVING CAST(total_incoming AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
                </when>
                <when test="columnKey == 'total_used'">
                    HAVING CAST(total_used AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
                </when>
                <when test="columnKey == 'incoming_count'">
                    HAVING CAST(incoming_count AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
                </when>
            </choose>
        </if>
        ORDER BY
        <choose>
            <when test="orderColumn != null and orderColumn != ''">
                ${orderColumn} ${order}
            </when>
            <otherwise>
                pi.part_number ASC
            </otherwise>
        </choose>
    </select>
    <!-- âœ… ìž¬ê³  ë¶€ì¡± ì¡°íšŒ (í˜„ìž¬ ìž¬ê³  ê¸°ì¤€) -->
    <select id="selectLowStock" resultType="map" parameterType="int">
        SELECT
            pi.part_number,
            pi.part_name,
            c.category_name,
            pi.unit,
            (SUM(pi.incoming_quantity) - COALESCE(SUM(pu.quantity_used), 0)) AS current_stock
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        LEFT JOIN part_usage pu ON pi.incoming_id = pu.incoming_id
        GROUP BY pi.part_number, pi.part_name, c.category_name, pi.unit
        HAVING current_stock &lt;= #{threshold}
        ORDER BY current_stock ASC
    </select>

    <!-- âœ… ìž…ê³  ì •ë³´ ìˆ˜ì • -->
    <update id="updateIncoming" parameterType="com.example.part.dto.PartIncomingDTO">
        UPDATE part_incoming
        SET
            part_number = #{partNumber},
            category_id = #{categoryId},
            part_name = #{partName},
            description = #{description},
            unit = #{unit},
            incoming_quantity = #{incomingQuantity},
            purchase_price = #{purchasePrice},
            currency = #{currency},
            exchange_rate = #{exchangeRate},
            original_price = #{originalPrice},
            purchase_date = #{purchaseDate},
            supplier = #{supplier},
            invoice_number = #{invoiceNumber},
            note = #{note}
        WHERE incoming_id = #{incomingId}
    </update>

    <!-- âœ… ì •ë ¬ (ë™ì ) -->
    <select id="getIncomingOrderBy" resultMap="incomingResultMap">
        SELECT
            pi.*,
            c.category_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        ORDER BY ${column} ${order}
    </select>

    <!-- ì¹´í…Œê³ ë¦¬ + ë¶€í’ˆëª…ìœ¼ë¡œ ê¸°ì¡´ ë¶€í’ˆ ì°¾ê¸° -->
    <select id="findByPartNameAndCategory" resultMap="incomingResultMap">
        SELECT
            pi.*,
            c.category_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        WHERE pi.category_id = #{categoryId}
        AND pi.part_name = #{partName}
        ORDER BY pi.created_at DESC
        LIMIT 1
    </select>

    <!-- ê²€ìƒ‰ + ì •ë ¬ í†µí•© -->
    <select id="searchWithSort" resultMap="incomingResultMap">
        SELECT
            pi.*,
            c.category_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        WHERE pi.part_name LIKE CONCAT('%', #{keyword}, '%')
        OR pi.part_number LIKE CONCAT('%', #{keyword}, '%')
        ORDER BY ${column} ${order}
    </select>

    <!-- ðŸ” ê³ ê¸‰ ê²€ìƒ‰ (ì»¬ëŸ¼ ê²€ìƒ‰ + +í¬í•¨ + -ì œì™¸ + ì „ì²´ê²€ìƒ‰) -->
    <select id="searchAdvanced" resultMap="incomingResultMap" parameterType="map">
        SELECT
            pi.*,
            c.category_name
        FROM part_incoming pi
        LEFT JOIN category c ON pi.category_id = c.category_id
        WHERE 1 = 1

        <!-- ================================
            1) ì»¬ëŸ¼ ê²€ìƒ‰ (column ì§€ì •ëœ ê²½ìš°)
            ================================ -->
        <if test="column != null and column != '' and keyword != null and keyword != ''">
            <choose>
                <!-- ìˆ«ìž ì»¬ëŸ¼ë„ LIKEë¡œ í¬í•¨ ê²€ìƒ‰ -->
                <when test="column == 'incoming_quantity' or column == 'purchase_price'">
                    AND CAST(${column} AS CHAR) LIKE CONCAT('%', #{keyword}, '%')
                </when>
                <!-- í…ìŠ¤íŠ¸ ì»¬ëŸ¼ì€ LIKE ê²€ìƒ‰ -->
                <otherwise>
                    AND ${column} LIKE CONCAT('%', #{keyword}, '%')
                </otherwise>
            </choose>
        </if>

        <!-- ===================================
            2) ì „ì²´ ê²€ìƒ‰ (columnì´ ì—†ì„ ë•Œë§Œ ì‹¤í–‰)
            =================================== -->
        <if test="(column == null or column == '')
                and keyword != null and keyword != ''">
            AND (
                pi.part_number LIKE CONCAT('%', #{keyword}, '%')
                OR pi.part_name LIKE CONCAT('%', #{keyword}, '%')
                OR c.category_name LIKE CONCAT('%', #{keyword}, '%')
            )
        </if>

        <!-- ================================
            3) + í¬í•¨ ê²€ìƒ‰
            ================================ -->
        <foreach collection="includeList" item="kw">
            AND (
                pi.part_number LIKE CONCAT('%', #{kw}, '%')
                OR pi.part_name LIKE CONCAT('%', #{kw}, '%')
                OR c.category_name LIKE CONCAT('%', #{kw}, '%')
            )
        </foreach>

        <!-- ================================
            4) - ì œì™¸ ê²€ìƒ‰
            ================================ -->
        <foreach collection="excludeList" item="kw">
            AND (
                pi.part_number NOT LIKE CONCAT('%', #{kw}, '%')
                AND pi.part_name NOT LIKE CONCAT('%', #{kw}, '%')
                AND c.category_name NOT LIKE CONCAT('%', #{kw}, '%')
            )
        </foreach>

        <!-- ================================
            5) ì •ë ¬ (sortColumnì´ ìžˆìœ¼ë©´ ê·¸ ì»¬ëŸ¼ìœ¼ë¡œ, ì—†ìœ¼ë©´ column ì‚¬ìš©)
            ================================ -->
        ORDER BY
        <choose>
            <when test="sortColumn != null and sortColumn != ''">
                ${sortColumn} ${order}
            </when>
            <when test="column != null and column != ''">
                ${column} ${order}
            </when>
            <otherwise>
                pi.created_at DESC
            </otherwise>
        </choose>
    </select>


</mapper>
